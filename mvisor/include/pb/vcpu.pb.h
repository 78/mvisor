// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: vcpu.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_vcpu_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_vcpu_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3019000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3019004 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_vcpu_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_vcpu_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_vcpu_2eproto;
class VcpuState;
struct VcpuStateDefaultTypeInternal;
extern VcpuStateDefaultTypeInternal _VcpuState_default_instance_;
PROTOBUF_NAMESPACE_OPEN
template<> ::VcpuState* Arena::CreateMaybeMessage<::VcpuState>(Arena*);
PROTOBUF_NAMESPACE_CLOSE

// ===================================================================

class VcpuState final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:VcpuState) */ {
 public:
  inline VcpuState() : VcpuState(nullptr) {}
  ~VcpuState() override;
  explicit constexpr VcpuState(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  VcpuState(const VcpuState& from);
  VcpuState(VcpuState&& from) noexcept
    : VcpuState() {
    *this = ::std::move(from);
  }

  inline VcpuState& operator=(const VcpuState& from) {
    CopyFrom(from);
    return *this;
  }
  inline VcpuState& operator=(VcpuState&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const VcpuState& default_instance() {
    return *internal_default_instance();
  }
  static inline const VcpuState* internal_default_instance() {
    return reinterpret_cast<const VcpuState*>(
               &_VcpuState_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(VcpuState& a, VcpuState& b) {
    a.Swap(&b);
  }
  inline void Swap(VcpuState* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(VcpuState* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  VcpuState* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<VcpuState>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const VcpuState& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom(const VcpuState& from);
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message* to, const ::PROTOBUF_NAMESPACE_ID::Message& from);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(VcpuState* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "VcpuState";
  }
  protected:
  explicit VcpuState(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  inline void RegisterArenaDtor(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kRegsFieldNumber = 2,
    kSregsFieldNumber = 3,
    kXsaveFieldNumber = 4,
    kXcrsFieldNumber = 5,
    kMsrsFieldNumber = 6,
    kLapicFieldNumber = 7,
    kDebugRegsFieldNumber = 8,
    kNestedStateFieldNumber = 9,
    kEventsFieldNumber = 10,
    kFpuFieldNumber = 12,
    kCpuidFieldNumber = 13,
    kTscKhzFieldNumber = 11,
    kMpStateFieldNumber = 1,
  };
  // bytes regs = 2;
  void clear_regs();
  const std::string& regs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_regs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_regs();
  PROTOBUF_NODISCARD std::string* release_regs();
  void set_allocated_regs(std::string* regs);
  private:
  const std::string& _internal_regs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_regs(const std::string& value);
  std::string* _internal_mutable_regs();
  public:

  // bytes sregs = 3;
  void clear_sregs();
  const std::string& sregs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sregs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sregs();
  PROTOBUF_NODISCARD std::string* release_sregs();
  void set_allocated_sregs(std::string* sregs);
  private:
  const std::string& _internal_sregs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sregs(const std::string& value);
  std::string* _internal_mutable_sregs();
  public:

  // bytes xsave = 4;
  void clear_xsave();
  const std::string& xsave() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xsave(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xsave();
  PROTOBUF_NODISCARD std::string* release_xsave();
  void set_allocated_xsave(std::string* xsave);
  private:
  const std::string& _internal_xsave() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xsave(const std::string& value);
  std::string* _internal_mutable_xsave();
  public:

  // bytes xcrs = 5;
  void clear_xcrs();
  const std::string& xcrs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_xcrs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_xcrs();
  PROTOBUF_NODISCARD std::string* release_xcrs();
  void set_allocated_xcrs(std::string* xcrs);
  private:
  const std::string& _internal_xcrs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_xcrs(const std::string& value);
  std::string* _internal_mutable_xcrs();
  public:

  // bytes msrs = 6;
  void clear_msrs();
  const std::string& msrs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_msrs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_msrs();
  PROTOBUF_NODISCARD std::string* release_msrs();
  void set_allocated_msrs(std::string* msrs);
  private:
  const std::string& _internal_msrs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_msrs(const std::string& value);
  std::string* _internal_mutable_msrs();
  public:

  // bytes lapic = 7;
  void clear_lapic();
  const std::string& lapic() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_lapic(ArgT0&& arg0, ArgT... args);
  std::string* mutable_lapic();
  PROTOBUF_NODISCARD std::string* release_lapic();
  void set_allocated_lapic(std::string* lapic);
  private:
  const std::string& _internal_lapic() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_lapic(const std::string& value);
  std::string* _internal_mutable_lapic();
  public:

  // bytes debug_regs = 8;
  void clear_debug_regs();
  const std::string& debug_regs() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_debug_regs(ArgT0&& arg0, ArgT... args);
  std::string* mutable_debug_regs();
  PROTOBUF_NODISCARD std::string* release_debug_regs();
  void set_allocated_debug_regs(std::string* debug_regs);
  private:
  const std::string& _internal_debug_regs() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_debug_regs(const std::string& value);
  std::string* _internal_mutable_debug_regs();
  public:

  // bytes nested_state = 9;
  void clear_nested_state();
  const std::string& nested_state() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_nested_state(ArgT0&& arg0, ArgT... args);
  std::string* mutable_nested_state();
  PROTOBUF_NODISCARD std::string* release_nested_state();
  void set_allocated_nested_state(std::string* nested_state);
  private:
  const std::string& _internal_nested_state() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_nested_state(const std::string& value);
  std::string* _internal_mutable_nested_state();
  public:

  // bytes events = 10;
  void clear_events();
  const std::string& events() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_events(ArgT0&& arg0, ArgT... args);
  std::string* mutable_events();
  PROTOBUF_NODISCARD std::string* release_events();
  void set_allocated_events(std::string* events);
  private:
  const std::string& _internal_events() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_events(const std::string& value);
  std::string* _internal_mutable_events();
  public:

  // bytes fpu = 12;
  void clear_fpu();
  const std::string& fpu() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_fpu(ArgT0&& arg0, ArgT... args);
  std::string* mutable_fpu();
  PROTOBUF_NODISCARD std::string* release_fpu();
  void set_allocated_fpu(std::string* fpu);
  private:
  const std::string& _internal_fpu() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_fpu(const std::string& value);
  std::string* _internal_mutable_fpu();
  public:

  // bytes cpuid = 13;
  void clear_cpuid();
  const std::string& cpuid() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_cpuid(ArgT0&& arg0, ArgT... args);
  std::string* mutable_cpuid();
  PROTOBUF_NODISCARD std::string* release_cpuid();
  void set_allocated_cpuid(std::string* cpuid);
  private:
  const std::string& _internal_cpuid() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_cpuid(const std::string& value);
  std::string* _internal_mutable_cpuid();
  public:

  // int64 tsc_khz = 11;
  void clear_tsc_khz();
  int64_t tsc_khz() const;
  void set_tsc_khz(int64_t value);
  private:
  int64_t _internal_tsc_khz() const;
  void _internal_set_tsc_khz(int64_t value);
  public:

  // uint32 mp_state = 1;
  void clear_mp_state();
  uint32_t mp_state() const;
  void set_mp_state(uint32_t value);
  private:
  uint32_t _internal_mp_state() const;
  void _internal_set_mp_state(uint32_t value);
  public:

  // @@protoc_insertion_point(class_scope:VcpuState)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr regs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sregs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xsave_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr xcrs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr msrs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr lapic_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr debug_regs_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr nested_state_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr events_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr fpu_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr cpuid_;
  int64_t tsc_khz_;
  uint32_t mp_state_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_vcpu_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// VcpuState

// uint32 mp_state = 1;
inline void VcpuState::clear_mp_state() {
  mp_state_ = 0u;
}
inline uint32_t VcpuState::_internal_mp_state() const {
  return mp_state_;
}
inline uint32_t VcpuState::mp_state() const {
  // @@protoc_insertion_point(field_get:VcpuState.mp_state)
  return _internal_mp_state();
}
inline void VcpuState::_internal_set_mp_state(uint32_t value) {
  
  mp_state_ = value;
}
inline void VcpuState::set_mp_state(uint32_t value) {
  _internal_set_mp_state(value);
  // @@protoc_insertion_point(field_set:VcpuState.mp_state)
}

// bytes regs = 2;
inline void VcpuState::clear_regs() {
  regs_.ClearToEmpty();
}
inline const std::string& VcpuState::regs() const {
  // @@protoc_insertion_point(field_get:VcpuState.regs)
  return _internal_regs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VcpuState::set_regs(ArgT0&& arg0, ArgT... args) {
 
 regs_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VcpuState.regs)
}
inline std::string* VcpuState::mutable_regs() {
  std::string* _s = _internal_mutable_regs();
  // @@protoc_insertion_point(field_mutable:VcpuState.regs)
  return _s;
}
inline const std::string& VcpuState::_internal_regs() const {
  return regs_.Get();
}
inline void VcpuState::_internal_set_regs(const std::string& value) {
  
  regs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VcpuState::_internal_mutable_regs() {
  
  return regs_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VcpuState::release_regs() {
  // @@protoc_insertion_point(field_release:VcpuState.regs)
  return regs_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VcpuState::set_allocated_regs(std::string* regs) {
  if (regs != nullptr) {
    
  } else {
    
  }
  regs_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), regs,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (regs_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    regs_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VcpuState.regs)
}

// bytes sregs = 3;
inline void VcpuState::clear_sregs() {
  sregs_.ClearToEmpty();
}
inline const std::string& VcpuState::sregs() const {
  // @@protoc_insertion_point(field_get:VcpuState.sregs)
  return _internal_sregs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VcpuState::set_sregs(ArgT0&& arg0, ArgT... args) {
 
 sregs_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VcpuState.sregs)
}
inline std::string* VcpuState::mutable_sregs() {
  std::string* _s = _internal_mutable_sregs();
  // @@protoc_insertion_point(field_mutable:VcpuState.sregs)
  return _s;
}
inline const std::string& VcpuState::_internal_sregs() const {
  return sregs_.Get();
}
inline void VcpuState::_internal_set_sregs(const std::string& value) {
  
  sregs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VcpuState::_internal_mutable_sregs() {
  
  return sregs_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VcpuState::release_sregs() {
  // @@protoc_insertion_point(field_release:VcpuState.sregs)
  return sregs_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VcpuState::set_allocated_sregs(std::string* sregs) {
  if (sregs != nullptr) {
    
  } else {
    
  }
  sregs_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), sregs,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sregs_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    sregs_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VcpuState.sregs)
}

// bytes xsave = 4;
inline void VcpuState::clear_xsave() {
  xsave_.ClearToEmpty();
}
inline const std::string& VcpuState::xsave() const {
  // @@protoc_insertion_point(field_get:VcpuState.xsave)
  return _internal_xsave();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VcpuState::set_xsave(ArgT0&& arg0, ArgT... args) {
 
 xsave_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VcpuState.xsave)
}
inline std::string* VcpuState::mutable_xsave() {
  std::string* _s = _internal_mutable_xsave();
  // @@protoc_insertion_point(field_mutable:VcpuState.xsave)
  return _s;
}
inline const std::string& VcpuState::_internal_xsave() const {
  return xsave_.Get();
}
inline void VcpuState::_internal_set_xsave(const std::string& value) {
  
  xsave_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VcpuState::_internal_mutable_xsave() {
  
  return xsave_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VcpuState::release_xsave() {
  // @@protoc_insertion_point(field_release:VcpuState.xsave)
  return xsave_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VcpuState::set_allocated_xsave(std::string* xsave) {
  if (xsave != nullptr) {
    
  } else {
    
  }
  xsave_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), xsave,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (xsave_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    xsave_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VcpuState.xsave)
}

// bytes xcrs = 5;
inline void VcpuState::clear_xcrs() {
  xcrs_.ClearToEmpty();
}
inline const std::string& VcpuState::xcrs() const {
  // @@protoc_insertion_point(field_get:VcpuState.xcrs)
  return _internal_xcrs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VcpuState::set_xcrs(ArgT0&& arg0, ArgT... args) {
 
 xcrs_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VcpuState.xcrs)
}
inline std::string* VcpuState::mutable_xcrs() {
  std::string* _s = _internal_mutable_xcrs();
  // @@protoc_insertion_point(field_mutable:VcpuState.xcrs)
  return _s;
}
inline const std::string& VcpuState::_internal_xcrs() const {
  return xcrs_.Get();
}
inline void VcpuState::_internal_set_xcrs(const std::string& value) {
  
  xcrs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VcpuState::_internal_mutable_xcrs() {
  
  return xcrs_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VcpuState::release_xcrs() {
  // @@protoc_insertion_point(field_release:VcpuState.xcrs)
  return xcrs_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VcpuState::set_allocated_xcrs(std::string* xcrs) {
  if (xcrs != nullptr) {
    
  } else {
    
  }
  xcrs_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), xcrs,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (xcrs_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    xcrs_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VcpuState.xcrs)
}

// bytes msrs = 6;
inline void VcpuState::clear_msrs() {
  msrs_.ClearToEmpty();
}
inline const std::string& VcpuState::msrs() const {
  // @@protoc_insertion_point(field_get:VcpuState.msrs)
  return _internal_msrs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VcpuState::set_msrs(ArgT0&& arg0, ArgT... args) {
 
 msrs_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VcpuState.msrs)
}
inline std::string* VcpuState::mutable_msrs() {
  std::string* _s = _internal_mutable_msrs();
  // @@protoc_insertion_point(field_mutable:VcpuState.msrs)
  return _s;
}
inline const std::string& VcpuState::_internal_msrs() const {
  return msrs_.Get();
}
inline void VcpuState::_internal_set_msrs(const std::string& value) {
  
  msrs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VcpuState::_internal_mutable_msrs() {
  
  return msrs_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VcpuState::release_msrs() {
  // @@protoc_insertion_point(field_release:VcpuState.msrs)
  return msrs_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VcpuState::set_allocated_msrs(std::string* msrs) {
  if (msrs != nullptr) {
    
  } else {
    
  }
  msrs_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), msrs,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (msrs_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    msrs_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VcpuState.msrs)
}

// bytes lapic = 7;
inline void VcpuState::clear_lapic() {
  lapic_.ClearToEmpty();
}
inline const std::string& VcpuState::lapic() const {
  // @@protoc_insertion_point(field_get:VcpuState.lapic)
  return _internal_lapic();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VcpuState::set_lapic(ArgT0&& arg0, ArgT... args) {
 
 lapic_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VcpuState.lapic)
}
inline std::string* VcpuState::mutable_lapic() {
  std::string* _s = _internal_mutable_lapic();
  // @@protoc_insertion_point(field_mutable:VcpuState.lapic)
  return _s;
}
inline const std::string& VcpuState::_internal_lapic() const {
  return lapic_.Get();
}
inline void VcpuState::_internal_set_lapic(const std::string& value) {
  
  lapic_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VcpuState::_internal_mutable_lapic() {
  
  return lapic_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VcpuState::release_lapic() {
  // @@protoc_insertion_point(field_release:VcpuState.lapic)
  return lapic_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VcpuState::set_allocated_lapic(std::string* lapic) {
  if (lapic != nullptr) {
    
  } else {
    
  }
  lapic_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), lapic,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (lapic_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    lapic_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VcpuState.lapic)
}

// bytes debug_regs = 8;
inline void VcpuState::clear_debug_regs() {
  debug_regs_.ClearToEmpty();
}
inline const std::string& VcpuState::debug_regs() const {
  // @@protoc_insertion_point(field_get:VcpuState.debug_regs)
  return _internal_debug_regs();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VcpuState::set_debug_regs(ArgT0&& arg0, ArgT... args) {
 
 debug_regs_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VcpuState.debug_regs)
}
inline std::string* VcpuState::mutable_debug_regs() {
  std::string* _s = _internal_mutable_debug_regs();
  // @@protoc_insertion_point(field_mutable:VcpuState.debug_regs)
  return _s;
}
inline const std::string& VcpuState::_internal_debug_regs() const {
  return debug_regs_.Get();
}
inline void VcpuState::_internal_set_debug_regs(const std::string& value) {
  
  debug_regs_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VcpuState::_internal_mutable_debug_regs() {
  
  return debug_regs_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VcpuState::release_debug_regs() {
  // @@protoc_insertion_point(field_release:VcpuState.debug_regs)
  return debug_regs_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VcpuState::set_allocated_debug_regs(std::string* debug_regs) {
  if (debug_regs != nullptr) {
    
  } else {
    
  }
  debug_regs_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), debug_regs,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (debug_regs_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    debug_regs_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VcpuState.debug_regs)
}

// bytes nested_state = 9;
inline void VcpuState::clear_nested_state() {
  nested_state_.ClearToEmpty();
}
inline const std::string& VcpuState::nested_state() const {
  // @@protoc_insertion_point(field_get:VcpuState.nested_state)
  return _internal_nested_state();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VcpuState::set_nested_state(ArgT0&& arg0, ArgT... args) {
 
 nested_state_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VcpuState.nested_state)
}
inline std::string* VcpuState::mutable_nested_state() {
  std::string* _s = _internal_mutable_nested_state();
  // @@protoc_insertion_point(field_mutable:VcpuState.nested_state)
  return _s;
}
inline const std::string& VcpuState::_internal_nested_state() const {
  return nested_state_.Get();
}
inline void VcpuState::_internal_set_nested_state(const std::string& value) {
  
  nested_state_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VcpuState::_internal_mutable_nested_state() {
  
  return nested_state_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VcpuState::release_nested_state() {
  // @@protoc_insertion_point(field_release:VcpuState.nested_state)
  return nested_state_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VcpuState::set_allocated_nested_state(std::string* nested_state) {
  if (nested_state != nullptr) {
    
  } else {
    
  }
  nested_state_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), nested_state,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (nested_state_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    nested_state_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VcpuState.nested_state)
}

// bytes events = 10;
inline void VcpuState::clear_events() {
  events_.ClearToEmpty();
}
inline const std::string& VcpuState::events() const {
  // @@protoc_insertion_point(field_get:VcpuState.events)
  return _internal_events();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VcpuState::set_events(ArgT0&& arg0, ArgT... args) {
 
 events_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VcpuState.events)
}
inline std::string* VcpuState::mutable_events() {
  std::string* _s = _internal_mutable_events();
  // @@protoc_insertion_point(field_mutable:VcpuState.events)
  return _s;
}
inline const std::string& VcpuState::_internal_events() const {
  return events_.Get();
}
inline void VcpuState::_internal_set_events(const std::string& value) {
  
  events_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VcpuState::_internal_mutable_events() {
  
  return events_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VcpuState::release_events() {
  // @@protoc_insertion_point(field_release:VcpuState.events)
  return events_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VcpuState::set_allocated_events(std::string* events) {
  if (events != nullptr) {
    
  } else {
    
  }
  events_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), events,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (events_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    events_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VcpuState.events)
}

// int64 tsc_khz = 11;
inline void VcpuState::clear_tsc_khz() {
  tsc_khz_ = int64_t{0};
}
inline int64_t VcpuState::_internal_tsc_khz() const {
  return tsc_khz_;
}
inline int64_t VcpuState::tsc_khz() const {
  // @@protoc_insertion_point(field_get:VcpuState.tsc_khz)
  return _internal_tsc_khz();
}
inline void VcpuState::_internal_set_tsc_khz(int64_t value) {
  
  tsc_khz_ = value;
}
inline void VcpuState::set_tsc_khz(int64_t value) {
  _internal_set_tsc_khz(value);
  // @@protoc_insertion_point(field_set:VcpuState.tsc_khz)
}

// bytes fpu = 12;
inline void VcpuState::clear_fpu() {
  fpu_.ClearToEmpty();
}
inline const std::string& VcpuState::fpu() const {
  // @@protoc_insertion_point(field_get:VcpuState.fpu)
  return _internal_fpu();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VcpuState::set_fpu(ArgT0&& arg0, ArgT... args) {
 
 fpu_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VcpuState.fpu)
}
inline std::string* VcpuState::mutable_fpu() {
  std::string* _s = _internal_mutable_fpu();
  // @@protoc_insertion_point(field_mutable:VcpuState.fpu)
  return _s;
}
inline const std::string& VcpuState::_internal_fpu() const {
  return fpu_.Get();
}
inline void VcpuState::_internal_set_fpu(const std::string& value) {
  
  fpu_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VcpuState::_internal_mutable_fpu() {
  
  return fpu_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VcpuState::release_fpu() {
  // @@protoc_insertion_point(field_release:VcpuState.fpu)
  return fpu_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VcpuState::set_allocated_fpu(std::string* fpu) {
  if (fpu != nullptr) {
    
  } else {
    
  }
  fpu_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), fpu,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (fpu_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    fpu_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VcpuState.fpu)
}

// bytes cpuid = 13;
inline void VcpuState::clear_cpuid() {
  cpuid_.ClearToEmpty();
}
inline const std::string& VcpuState::cpuid() const {
  // @@protoc_insertion_point(field_get:VcpuState.cpuid)
  return _internal_cpuid();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void VcpuState::set_cpuid(ArgT0&& arg0, ArgT... args) {
 
 cpuid_.SetBytes(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:VcpuState.cpuid)
}
inline std::string* VcpuState::mutable_cpuid() {
  std::string* _s = _internal_mutable_cpuid();
  // @@protoc_insertion_point(field_mutable:VcpuState.cpuid)
  return _s;
}
inline const std::string& VcpuState::_internal_cpuid() const {
  return cpuid_.Get();
}
inline void VcpuState::_internal_set_cpuid(const std::string& value) {
  
  cpuid_.Set(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, value, GetArenaForAllocation());
}
inline std::string* VcpuState::_internal_mutable_cpuid() {
  
  return cpuid_.Mutable(::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::EmptyDefault{}, GetArenaForAllocation());
}
inline std::string* VcpuState::release_cpuid() {
  // @@protoc_insertion_point(field_release:VcpuState.cpuid)
  return cpuid_.Release(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), GetArenaForAllocation());
}
inline void VcpuState::set_allocated_cpuid(std::string* cpuid) {
  if (cpuid != nullptr) {
    
  } else {
    
  }
  cpuid_.SetAllocated(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), cpuid,
      GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (cpuid_.IsDefault(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited())) {
    cpuid_.Set(&::PROTOBUF_NAMESPACE_ID::internal::GetEmptyStringAlreadyInited(), "", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:VcpuState.cpuid)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)


// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_vcpu_2eproto
